<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bebek Manyun vs Zombi ‚Äî Fix Terbaru</title>
  <style>
    :root{--bg:#98d6ff;--ground:#6b8f2f;--ui:#0f172a}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg)}
    body{display:flex;align-items:center;justify-content:center;padding:10px;}
    /* Wrapper: gunakan aspect-ratio agar tinggi proporsional pada HP */
    #gameWrap{
      width:100%;
      max-width:900px;
      aspect-ratio: 3 / 2;        /* 900x600 = 3:2 */
      box-shadow:0 10px 30px rgba(0,0,0,0.25);
      border-radius:12px;
      overflow:hidden;
      background:white;
      position:relative;
      padding-bottom:72px;       /* beri ruang bawah supaya tombol touch tidak menutupi area gameplay */
      box-sizing:border-box;
    }

    /* Canvas responsive: penuhi area wrapper */
    canvas{
      display:block;
      width:100%;
      height:100%;
      max-width:900px;
      background:linear-gradient(#cfefff, #eaf9ff);
      margin:0 auto;
      transform:none;
    }

    .hud{
      position:absolute; left:12px; top:12px;
      color:var(--ui); font-weight:700; z-index:60;
    }
    .hud .score{font-size:20px}
    .hud .hp{margin-top:6px;font-size:14px}
    .hud .wave{margin-top:4px;font-size:12px;color:#475569}

    .controls{position:absolute; right:12px; top:12px; text-align:right; z-index:50}
    .controls small{display:block;color:#334155;font-size:11px}
    .centerOverlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      flex-direction:column; gap:10px; background:rgba(15,23,42,0.85); backdrop-filter:blur(4px); z-index:100;
    }
    .centerOverlay h1{color:#fff;margin:0;font-size:28px}
    .centerOverlay p{color:#cbd5e1;margin:0;text-align:center;max-width:420px;line-height:1.5}
    .btn{background:#0f172a;color:white;padding:12px 24px;border-radius:10px;border:none;font-weight:700;cursor:pointer;font-size:16px}
    .touch-controls{
      position:absolute;
      left:12px;
      bottom:18px; /* naik sedikit supaya tidak menutupi area tanah */
      display:flex;
      gap:8px;
      z-index:30;
    }
    .touch-button{
      width:64px;height:64px;border-radius:12px;background:rgba(0,0,0,0.18);
      display:flex;align-items:center;justify-content:center;font-weight:800;color:#fff;user-select:none;
      touch-action:none;border:2px solid rgba(255,255,255,0.18)
    }
    .touch-button:active{transform:scale(0.96)}
    .hp-bar{width:150px;height:12px;background:#334155;border-radius:6px;overflow:hidden;margin-top:6px}
    .hp-fill{height:100%;background:linear-gradient(90deg,#22c55e,#16a34a);transition:width 0.2s}
    #muteBtn{margin-left:8px;padding:6px 10px;font-size:12px;border-radius:8px}
    @media (max-width:768px){
      .controls{display:none}
    }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="gameCanvas" width="900" height="600"></canvas>

    <div class="hud">
      <div class="score">Skor: <span id="score">0</span></div>
      <div class="hp">
        HP: <span id="hp">100</span>
        <div class="hp-bar"><div class="hp-fill" id="hpBar" style="width:100%"></div></div>
      </div>
      <div class="wave">Gelombang: <span id="wave">1</span></div>
    </div>

    <div class="controls" id="desktopControls">
      <small>Kontrol: ‚Üê ‚Üí / A D ‚Äî Lompat: ‚Üë / W ‚Äî Serang: Space (tahan)</small>
      <small style="margin-top:4px">Tekan ESC untuk pause</small>
      <div style="margin-top:8px">
        <button id="muteBtn" class="btn" style="padding:6px 10px;font-size:12px">üîä</button>
      </div>
    </div>

    <div id="overlayStart" class="centerOverlay">
      <h1 style="margin:0">ü¶Ü Bebek Manyun vs Zombi üßü</h1>
      <p style="margin:0">Tekan tombol <strong>Mulai Bermain</strong>. Gunakan Space (tahan) untuk menembak. Coba double-jump!</p>
      <button id="startBtn" class="btn">üéÆ Mulai Bermain</button>
      <small style="color:#94a3b8">Cocok untuk desktop dan mobile</small>
    </div>

    <div class="touch-controls" id="touchControls" style="display:none">
      <div class="touch-button" id="leftBtn">‚óÄ</div>
      <div class="touch-button" id="jumpBtn">‚ñ≤</div>
      <div class="touch-button" id="rightBtn">‚ñ∂</div>
      <div class="touch-button" id="attackBtn">QUAK</div>
    </div>
  </div>

<script>
// ===== Bebek Manyun vs Zombi ‚Äî Final Fix =====

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// logical game coords (always 900x600)
let W = 900, H = 600;
let GROUND_Y = H - 80;

const overlay = document.getElementById('overlayStart');
const startBtn = document.getElementById('startBtn');
const scoreEl = document.getElementById('score');
const hpEl = document.getElementById('hp');
const hpBar = document.getElementById('hpBar');
const waveEl = document.getElementById('wave');
const touchControls = document.getElementById('touchControls');
const muteBtn = document.getElementById('muteBtn');
const attackBtn = document.getElementById('attackBtn');

let running = false;
let paused = false;
let score = 0;
let wave = 1;
let spawnTimer = 0;
let spawnInterval = 120;
let entities = [];
let particles = [];
let keys = {};         // hold keys (e.g. ' ' for space)
let keysPressed = {};  // one-shot flags (jump)
let highScore = parseInt(localStorage.getItem('bebekHighScore') || '0');

const MAX_PARTICLES = 450;

const player = {
  x: 120, y: 0, w: 60, h: 48,
  vx: 0, vy: 0, speed: 4.2,
  onGround: false,
  hp: 100,
  maxHp: 100,
  attackCooldown: 0,
  invulnerable: 0,
  facing: 1,
  canDoubleJump: true
};

const GRAV = 0.6, FRICTION = 0.88;

// ---------------- Audio (WebAudio) ----------------
let audioCtx = null;
let masterGain = null;
let muted = false;

function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;
  masterGain.connect(audioCtx.destination);
}

function playOsc({type='sine', freq=440, dur=0.12, vol=0.5, pan=0} = {}){
  if(!audioCtx || muted) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  const p = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;
  o.type = type; o.frequency.value = freq;
  g.gain.value = 0;
  o.connect(g);
  if(p){ g.connect(p); p.connect(masterGain); if(p.pan) p.pan.value = pan; }
  else g.connect(masterGain);
  const now = audioCtx.currentTime;
  g.gain.setValueAtTime(0, now);
  g.gain.linearRampToValueAtTime(vol, now + 0.01);
  g.gain.exponentialRampToValueAtTime(0.001, now + dur);
  o.start(now); o.stop(now + dur + 0.03);
}

function playNoise({dur=0.08, vol=0.6} = {}){
  if(!audioCtx || muted) return;
  const bufferSize = Math.floor(audioCtx.sampleRate * dur);
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * Math.exp(-i / (bufferSize*0.8));
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const g = audioCtx.createGain(); g.gain.value = vol;
  src.connect(g); g.connect(masterGain);
  src.start();
}

function playSound(name){
  if(!audioCtx || muted) return;
  switch(name){
    case 'quack':
      playOsc({type:'square', freq:600, dur:0.06, vol:0.12});
      playOsc({type:'sine', freq:900, dur:0.10, vol:0.06});
      break;
    case 'gun':
      playOsc({type:'square', freq:1200, dur:0.06, vol:0.28});
      playNoise({dur:0.06, vol:0.14});
      break;
    case 'hit':
      playOsc({type:'sine', freq:120, dur:0.16, vol:0.22});
      playNoise({dur:0.05, vol:0.06});
      break;
    case 'enemyDie':
      playOsc({type:'triangle', freq:200, dur:0.22, vol:0.18});
      playOsc({type:'sine', freq:380, dur:0.16, vol:0.10});
      break;
    case 'gameOver':
      playOsc({type:'square', freq:90, dur:0.6, vol:0.22});
      break;
    default: break;
  }
}

// ---------------- Zombie ambience loop ----------------
let zombieAmbience = null;
function startZombieAmbience(){
  if(!audioCtx || muted) return;
  if(zombieAmbience) return;
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value = 60 + Math.random()*20;
  const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
  const d = noiseBuf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(d.length*0.4));
  const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf; noise.loop=true;
  const lowpass = audioCtx.createBiquadFilter(); lowpass.type='lowpass'; lowpass.frequency.value = 800;
  const g1 = audioCtx.createGain(); g1.gain.value = 0.06;
  const g2 = audioCtx.createGain(); g2.gain.value = 0.02;
  osc.connect(g1); noise.connect(lowpass); lowpass.connect(g2);
  const master = audioCtx.createGain(); master.gain.value = 0.0;
  g1.connect(master); g2.connect(master); master.connect(masterGain || audioCtx.destination);
  const now = audioCtx.currentTime;
  master.gain.linearRampToValueAtTime(0.5, now + 1.2);
  osc.start(); noise.start();
  zombieAmbience = {osc, noise, master};
}
function stopZombieAmbience(){
  if(!zombieAmbience) return;
  const now = audioCtx.currentTime;
  zombieAmbience.master.gain.cancelScheduledValues(now);
  zombieAmbience.master.gain.setValueAtTime(zombieAmbience.master.gain.value, now);
  zombieAmbience.master.gain.linearRampToValueAtTime(0.0, now + 0.8);
  setTimeout(()=>{
    try{ zombieAmbience.osc.stop(); zombieAmbience.noise.stop(); }catch(e){}
    zombieAmbience = null;
  }, 900);
}

// ---------------- Helpers ----------------
function rand(min, max){ return Math.random()*(max-min)+min; }

// ---------------- Spawns ----------------
function spawnZombie(){
  const z = {
    type: 'zombie',
    x: W + 60,
    y: GROUND_Y - 48,
    w: 52, h: 64,
    vx: rand(-1.6, -1.0) - Math.min(0.8, score/400),
    hp: 20 + Math.floor(score/40) + wave * 5,
    maxHp: 20 + Math.floor(score/40) + wave * 5,
    attackTimer: 0,
    walkPhase: Math.random()*Math.PI*2
  };
  entities.push(z);
  if(audioCtx && !zombieAmbience) startZombieAmbience();
}

function spawnBat(){
  const b = {
    type: 'bat',
    x: W + 60,
    y: rand(120, GROUND_Y-200),
    w:40, h:30,
    vx: rand(-2.6, -1.6),
    hp: 10 + wave * 2,
    maxHp: 10 + wave * 2,
    wobble: Math.random()*10
  };
  entities.push(b);
}

// ---------------- Shooting ----------------
function shoot(){
  if(player.attackCooldown > 0) return;
  player.attackCooldown = 12;   // rate of fire (smaller = faster)
  const p = {
    type: 'quack',
    x: player.x + (player.facing > 0 ? player.w : -22),
    y: player.y + 18,
    vx: 10 * player.facing,
    w: 20, h: 12,
    dmg: 18 + Math.floor(wave/2)
  };
  entities.push(p);
  createParticles(p.x, p.y, 4, '#8be0ff');
  playSound('gun');
}

// ---------------- Particles ----------------
function createParticles(x,y,count,color){
  for(let i=0;i<count;i++){
    particles.push({
      x: x,
      y: y,
      vx: rand(-3,3),
      vy: rand(-4,-1),
      life: 30,
      maxLife: 30,
      color: color || '#ffd54a',
      size: rand(3,8)
    });
  }
  if(particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
}

// ---------------- Update ----------------
function update(){
  if(!running || paused) return;

  // movement
  if(keys['ArrowLeft'] || keys['a']){
    player.vx = Math.max(player.vx - 0.85, -player.speed);
    player.facing = -1;
  }
  if(keys['ArrowRight'] || keys['d']){
    player.vx = Math.min(player.vx + 0.85, player.speed);
    player.facing = 1;
  }
  if(!(keys['ArrowLeft']||keys['a']||keys['ArrowRight']||keys['d'])) player.vx *= FRICTION;

  // jump (one-shot)
  if(keysPressed['up']){
    keysPressed['up'] = false;
    if(player.onGround){
      player.vy = -18;
      player.onGround = false;
      player.canDoubleJump = true;
      playSound('quack');
    } else if(player.canDoubleJump){
      player.vy = -15;
      player.canDoubleJump = false;
      createParticles(player.x + player.w/2, player.y + player.h/2, 8, '#8be0ff');
      playSound('quack');
    }
  }

  // hold to fire
  if(keys[' ']) shoot();

  // physics
  player.vy += GRAV;
  player.x += player.vx;
  player.y += player.vy;

  if(player.y + player.h >= GROUND_Y){
    const wasAir = !player.onGround;
    player.y = GROUND_Y - player.h;
    player.vy = 0;
    player.onGround = true;
    if(wasAir) player.canDoubleJump = true;
  }
  if(player.x < 10) player.x = 10;
  if(player.x + player.w > W - 10) player.x = W - 10 - player.w;
  if(player.attackCooldown>0) player.attackCooldown--;
  if(player.invulnerable>0) player.invulnerable--;

  // wave progression
  if(score > wave * 150 && entities.filter(e=>e.type==='zombie'||e.type==='bat').length === 0){
    wave++;
    waveEl.textContent = wave;
    spawnInterval = Math.max(28, 120 - wave * 8);
  }

  // spawn
  spawnTimer++;
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    const sc = Math.min(0.72, 0.25 + score/260);
    if(Math.random() < sc) spawnZombie();
    if(Math.random() < 0.15 + Math.min(0.45, score/520)) spawnBat();
  }

  // entities
  for(let i=entities.length-1;i>=0;i--){
    const e = entities[i];

    if(e.type === 'zombie'){
      e.x += e.vx;
      e.walkPhase += 0.08 * Math.abs(e.vx) * 1.4;
      e.attackTimer++;

      if(e.x < player.x + player.w && e.x + e.w > player.x &&
         e.y + e.h > player.y + 10 && e.attackTimer > 30 && player.invulnerable <= 0){
        player.hp -= 6;
        player.invulnerable = 28;
        e.attackTimer = 0;
        createParticles(player.x + player.w/2, player.y + player.h/2, 6, '#ff4444');
        playSound('hit');
      }

      if(e.x + e.w < -60) entities.splice(i,1);
    }

    if(e.type === 'bat'){
      e.x += e.vx;
      e.wobble += 0.18;
      e.y += Math.sin(e.wobble) * 1.6;

      if(e.x < player.x + player.w && e.x + e.w > player.x &&
         e.y < player.y + player.h && e.y + e.h > player.y && player.invulnerable <= 0){
        player.hp -= 3;
        player.invulnerable = 26;
        createParticles(player.x + player.w/2, player.y + player.h/2, 4, '#ff4444');
        playSound('hit');
      }

      if(e.x + e.w < -60) entities.splice(i,1);
    }

    if(e.type === 'quack'){
      e.x += e.vx;

      for(let j=entities.length-1;j>=0;j--){
        const t = entities[j];
        if(t===e) continue;
        if(t.type==='zombie' || t.type==='bat'){
          if(e.x < t.x + t.w && e.x + e.w > t.x &&
             e.y < t.y + t.h && e.y + e.h > t.y){
            t.hp -= e.dmg;
            t.x += 10 * Math.sign(e.vx);
            createParticles(t.x + t.w/2, t.y + t.h/2, 8, '#22c55e');
            const idx = entities.indexOf(e); if(idx>=0) entities.splice(idx,1);
            break;
          }
        }
      }

      if(e.x < -100 || e.x > W + 100){
        const idx = entities.indexOf(e); if(idx>=0) entities.splice(idx,1);
      }
    }

    if((e.type==='zombie' || e.type==='bat') && e.hp <= 0){
      const pts = (e.type==='zombie')? 35 : 16;
      score += pts;
      createParticles(e.x + e.w/2, e.y + e.h/2, 14, '#ffd54a');
      playSound('enemyDie');
      entities.splice(i,1);
    }
  }

  // ambience stop when no zombies
  if(!entities.some(x=>x.type==='zombie') && zombieAmbience) stopZombieAmbience();

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.28; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }

  // lose
  if(player.hp <= 0){
    playSound('gameOver');
    endGame();
  }

  // UI
  scoreEl.textContent = Math.floor(score);
  hpEl.textContent = Math.max(0, Math.floor(player.hp));
  hpBar.style.width = Math.max(0, (player.hp / player.maxHp) * 100) + '%';
  if(player.hp > 60) hpBar.style.background = 'linear-gradient(90deg,#22c55e,#16a34a)';
  else if(player.hp > 30) hpBar.style.background = 'linear-gradient(90deg,#eab308,#ca8a04)';
  else hpBar.style.background = 'linear-gradient(90deg,#ef4444,#dc2626)';
}

// ---------------- Draw ----------------
function draw(){
  // logical canvas cleared
  ctx.clearRect(0,0,W,H);

  // background
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#cfefff'); g.addColorStop(1,'#eaf9ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // clouds
  const cloudOffset = (Date.now() % 60000) / 120;
  for(let i=0;i<5;i++){
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    ctx.ellipse(100 + i*200 + cloudOffset, 80 + Math.sin(i)*18, 92, 36, 0, 0, Math.PI*2);
    ctx.fillStyle='#ffffff'; ctx.fill(); ctx.globalAlpha = 1;
  }

  // ground
  ctx.fillStyle = '#6b8f2f'; ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  ctx.fillStyle = '#5a7a28';
  for(let i=0;i<20;i++) ctx.fillRect(i*45 - (Date.now()/20)%45, GROUND_Y, 25, 4);

  // particles
  for(const p of particles){
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // player
  if(player.invulnerable <= 0 || Math.floor(Date.now()/100) % 2 === 0){
    drawDuck(player.x, player.y, player.w, player.h, player.facing);
  }

  // entities and HP bars
  for(const e of entities){
    if(e.type === 'zombie') drawZombie(e.x, e.y, e.w, e.h, e.walkPhase);
    if(e.type === 'bat') drawBat(e.x, e.y, e.w, e.h);
    if(e.type === 'quack') drawQuack(e.x, e.y, e.w, e.h);

    if(e.type === 'zombie' || e.type === 'bat'){
      const hpPct = Math.max(0, e.hp / (e.maxHp || 1));
      ctx.fillStyle = '#334155';
      ctx.fillRect(e.x, e.y - 8, e.w, 4);
      ctx.fillStyle = hpPct > 0.5 ? '#22c55e' : hpPct > 0.25 ? '#eab308' : '#ef4444';
      ctx.fillRect(e.x, e.y - 8, e.w * hpPct, 4);
    }
  }

  // pause overlay
  if(paused){
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 48px Inter'; ctx.textAlign = 'center';
    ctx.fillText('PAUSE', W/2, H/2); ctx.font='18px Inter';
    ctx.fillText('Tekan ESC untuk melanjutkan', W/2, H/2 + 40); ctx.textAlign = 'left';
  }
}

// ---------------- Draw helpers (with adjusted weapon pos) ----------------
function drawDuck(x,y,w,h,facing){
  ctx.save();
  ctx.translate(x + w/2, y + h/2);
  ctx.scale(facing,1);
  ctx.translate(-(x + w/2), -(y + h/2));

  // body
  const bodyX = x + w*0.45, bodyY = y + h*0.5;
  ctx.beginPath(); ctx.fillStyle = '#ffd754';
  ctx.ellipse(bodyX, bodyY, w*0.45, h*0.55, 0, 0, Math.PI*2); ctx.fill();

  // shading
  ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.06)';
  ctx.ellipse(bodyX - 8, bodyY + 4, w*0.32, h*0.35, 0, 0, Math.PI*2); ctx.fill();

  // wing
  ctx.fillStyle = '#ffcc33'; ctx.beginPath(); ctx.ellipse(x + w*0.25, y + h*0.5, w*0.18, h*0.28, -0.3, 0, Math.PI*2); ctx.fill();

  // head
  ctx.fillStyle = '#ffd754'; ctx.beginPath(); ctx.arc(x + w*0.4, y + h*0.28, w*0.22, 0, Math.PI*2); ctx.fill();

  // eye
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x + w*0.33, y + h*0.25, 7,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#052022'; ctx.beginPath(); ctx.arc(x + w*0.33, y + h*0.25, 4,0,Math.PI*2); ctx.fill();

  // sad mouth
  ctx.strokeStyle = '#5b3a00'; ctx.lineWidth=2; ctx.beginPath();
  ctx.moveTo(x + w*0.28, y + h*0.35); ctx.quadraticCurveTo(x + w*0.33, y + h*0.40, x + w*0.40, y + h*0.35); ctx.stroke();

  // feet
  ctx.fillStyle = '#ff8a00'; ctx.fillRect(x + w*0.28, y+h-6, 10, 4); ctx.fillRect(x + w*0.54, y+h-6, 10, 4);

  // weapon (stylized AK) - adjusted position + rotation
  ctx.save();
  const gunX = x + w*0.5;   // lebih dekat ke badan
  const gunY = y + h*0.42;  // sedikit lebih atas
  ctx.translate(gunX, gunY);
  ctx.rotate(-0.12);
  ctx.fillStyle = '#333'; ctx.fillRect(-8, -5, 60, 9); // body
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.moveTo(18, -5); ctx.lineTo(30, -5); ctx.lineTo(30, 7); ctx.lineTo(18, 7); ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#111'; ctx.fillRect(48, -2, 22, 3); // barrel
  ctx.fillStyle = '#2b2b2b'; ctx.fillRect(4, 6, 8, 14); // grip
  ctx.restore();

  ctx.restore();
}

function drawZombie(x,y,w,h,phase=0){
  ctx.save();
  ctx.translate(x, y);
  ctx.fillStyle = '#6aa56a'; ctx.fillRect(8,20,w-16,h-20); ctx.fillRect(4,0,w-8,24);
  const swing = Math.sin(phase) * 6;
  ctx.fillStyle = '#5c9f5b';
  ctx.fillRect(-2, 28 + swing*0.6, 8, 25);
  ctx.fillRect(w-6, 28 - swing*0.6, 8, 25);
  ctx.fillStyle = '#fff'; ctx.fillRect(12,6,10,10); ctx.fillRect(w-22,6,10,10);
  ctx.fillStyle = '#8b0000'; ctx.fillRect(15,9,4,4); ctx.fillRect(w-19,9,4,4);
  ctx.fillStyle = '#062b3a'; ctx.fillRect(w*0.3, 18, w*0.4, 3);
  const legShift = Math.sin(phase) * 4;
  ctx.fillRect(w*0.2, h-10 + legShift, 10, 12);
  ctx.fillRect(w*0.6, h-10 - legShift, 10, 12);
  ctx.restore();
}

function drawBat(x,y,w,h){
  ctx.save();
  ctx.translate(x,y);
  ctx.fillStyle = '#2d2d2d'; ctx.beginPath(); ctx.ellipse(w*0.5, h*0.5, w*0.3, h*0.4, 0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#3b3b3b'; ctx.beginPath(); ctx.ellipse(w*0.15, h*0.5, w*0.35, h*0.3, -0.5,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(w*0.85, h*0.5, w*0.35, h*0.3, 0.5,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(w*0.4, h*0.4, 3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(w*0.6, h*0.4, 3,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawQuack(x,y,w,h){
  ctx.fillStyle = '#8be0ff'; ctx.beginPath(); ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='#062b3a'; ctx.font='bold 10px Inter'; ctx.fillText('Q', x+5, y+9);
}

// ---------------- Loop control ----------------
function loop(){ update(); draw(); if(running) requestAnimationFrame(loop); }

function startGame(){
  initAudio();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  running = true; paused = false;
  score = 0; wave = 1; entities = []; particles = [];
  player.hp = 100; player.x = 120; player.y = GROUND_Y - player.h; player.vx=0; player.vy=0;
  player.invulnerable = 0; player.facing = 1; player.canDoubleJump = true;
  spawnTimer = 0; spawnInterval = 120;
  overlay.style.display = 'none';
  touchControls.style.display = /Mobi|Android/i.test(navigator.userAgent) ? 'flex' : 'none';
  requestAnimationFrame(loop);
}

function endGame(){
  running = false;
  if(score > highScore){ highScore = score; localStorage.setItem('bebekHighScore', highScore); }
  overlay.style.display = 'flex';
  overlay.querySelector('h1').textContent = '‚ò†Ô∏è Game Over!';
  overlay.querySelector('p').innerHTML = `<strong>Skor Akhir: ${Math.floor(score)}</strong><br>Gelombang: ${wave}<br>High Score: ${highScore}<br><br>Tekan tombol untuk bermain lagi!`;
}

// ---------------- Input (hold-fire + one-shot jump) ----------------
window.addEventListener('keydown', e=>{
  if(e.code === 'Space'){ e.preventDefault(); keys[' '] = true; }
  if(e.key === 'ArrowUp' || e.key === 'w'){ keysPressed['up'] = true; }
  keys[e.key] = true;
  if(e.key === 'Escape') togglePause();
});

window.addEventListener('keyup', e=>{
  if(e.code === 'Space'){ keys[' '] = false; }
  keys[e.key] = false;
});

// Attack button (hold)
function startFiring(){ keys[' '] = true; }
function stopFiring(){ keys[' '] = false; }

attackBtn.addEventListener('touchstart', e=>{ e.preventDefault(); startFiring(); });
attackBtn.addEventListener('touchend', e=>{ e.preventDefault(); stopFiring(); });
attackBtn.addEventListener('touchcancel', e=>{ e.preventDefault(); stopFiring(); });
attackBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); startFiring(); });
window.addEventListener('pointerup', e=>{ stopFiring(); });

// touch movement buttons
function addTouch(btn, key, isOneShot=false){
  btn.addEventListener('touchstart', e=>{ e.preventDefault(); if(isOneShot) keysPressed[key]=true; else keys[key]=true; });
  btn.addEventListener('touchend', e=>{ e.preventDefault(); if(!isOneShot) keys[key]=false; });
  btn.addEventListener('touchcancel', e=>{ e.preventDefault(); if(!isOneShot) keys[key]=false; });
}
addTouch(document.getElementById('leftBtn'), 'ArrowLeft');
addTouch(document.getElementById('rightBtn'), 'ArrowRight');
addTouch(document.getElementById('jumpBtn'), 'up', true);

// mute toggle
muteBtn.addEventListener('click', ()=>{
  muted = !muted;
  muteBtn.textContent = muted ? 'üîá' : 'üîä';
  if(masterGain) masterGain.gain.value = muted ? 0 : 0.9;
});

// ---------------- Responsive sizing ----------------
function resizeCanvas(){
  const wrap = document.getElementById('gameWrap');
  const rect = wrap.getBoundingClientRect();
  const desiredWidth = Math.min(rect.width, 900);
  const desiredHeight = Math.round(desiredWidth * (600 / 900));
  canvas.style.width = desiredWidth + 'px';
  canvas.style.height = desiredHeight + 'px';
  // logical coords remain 900x600
  W = 900; H = 600; GROUND_Y = H - 80;
  if(player.x + player.w > W) player.x = W - player.w - 10;
  if(player.y + player.h > GROUND_Y) player.y = GROUND_Y - player.h;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// prevent context menu on touch buttons
document.querySelectorAll('.touch-button').forEach(btn => btn.addEventListener('contextmenu', e=>e.preventDefault()));

// demo start screen
let demoTimer = 0;
function demoAnimation(){
  if(!running){
    demoTimer++;
    if(demoTimer > 90 && Math.random() < 0.12){
      if(Math.random() < 0.5) spawnZombie(); else spawnBat();
      demoTimer = 0;
    }
    for(let i=entities.length-1;i>=0;i--){
      const e = entities[i];
      e.x += e.vx;
      if(e.wobble !== undefined){ e.wobble += 0.15; e.y += Math.sin(e.wobble)*1.5; }
      if(e.x < -120) entities.splice(i,1);
    }
    draw();
    requestAnimationFrame(demoAnimation);
  }
}
demoAnimation();

startBtn.addEventListener('click', ()=>{ startGame(); });

function togglePause(){ if(!running) return; paused = !paused; if(!paused) requestAnimationFrame(loop); }

console.log('ü¶Ü Bebek Manyun vs Zombi ‚Äî Versi perbaikan siap');
</script>
</body>
</html>
