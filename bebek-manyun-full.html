<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bebek Manyun vs Zombi ‚Äî Fix Audio & Controls</title>
  <style>
    :root{--bg:#98d6ff;--ground:#6b8f2f;--ui:#0f172a}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg)}
    body{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:12px 8px 24px;}
    /* Wrapper: gunakan aspect-ratio agar tinggi proporsional pada HP */
    #gameWrap{
      width:95vw;                /* responsive untuk HP (95% lebar layar) */
      max-width:900px;
      aspect-ratio: 3 / 2;       /* 900x600 = 3:2 */
      box-shadow:0 10px 30px rgba(0,0,0,0.25);
      border-radius:12px;
      overflow:hidden;
      background:white;
      position:relative;
      box-sizing:border-box;
      margin-bottom:12px;
    }

    /* Canvas responsive: penuhi area wrapper */
    canvas{
      display:block;
      width:100%;
      height:100%;
      background:linear-gradient(#cfefff, #eaf9ff);
    }

    .hud{
      position:absolute; left:12px; top:12px;
      color:var(--ui); font-weight:700; z-index:60;
    }
    .hud .score{font-size:20px}
    .hud .hp{margin-top:6px;font-size:14px}
    .hud .wave{margin-top:4px;font-size:12px;color:#475569}

    .controls{position:absolute; right:12px; top:12px; text-align:right; z-index:50}
    .controls small{display:block;color:#334155;font-size:11px}
    .centerOverlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      flex-direction:column; gap:10px; background:rgba(15,23,42,0.85); backdrop-filter:blur(4px); z-index:100;
    }
    .centerOverlay h1{color:#fff;margin:0;font-size:28px}
    .centerOverlay p{color:#cbd5e1;margin:0;text-align:center;max-width:420px;line-height:1.5}
    .btn{background:#0f172a;color:white;padding:12px 24px;border-radius:10px;border:none;font-weight:700;cursor:pointer;font-size:16px}
    /* Touch controls moved BELOW the game (not inside wrapper) */
    #touchArea{ width:95vw; max-width:900px; display:flex; justify-content:center; gap:12px; align-items:flex-end; margin-top:6px; }
    .touch-controls{
      display:flex; gap:10px; align-items:center; justify-content:center;
      padding:8px 6px; background:transparent;
    }
    .touch-button{
      width:72px;height:72px;border-radius:12px;background:rgba(0,0,0,0.18);
      display:flex;align-items:center;justify-content:center;font-weight:800;color:#fff;user-select:none;
      touch-action:none;border:2px solid rgba(255,255,255,0.18); font-size:18px;
    }
    .touch-button:active{transform:scale(0.96)}
    .hp-bar{width:150px;height:12px;background:#334155;border-radius:6px;overflow:hidden;margin-top:6px}
    .hp-fill{height:100%;background:linear-gradient(90deg,#22c55e,#16a34a);transition:width 0.2s}
    #muteBtn{margin-left:8px;padding:6px 10px;font-size:12px;border-radius:8px}
    @media (max-width:420px){
      .touch-button{width:64px;height:64px;font-size:16px}
      #touchArea{gap:8px}
    }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="gameCanvas" width="900" height="600"></canvas>

    <div class="hud">
      <div class="score">Skor: <span id="score">0</span></div>
      <div class="hp">
        HP: <span id="hp">100</span>
        <div class="hp-bar"><div class="hp-fill" id="hpBar" style="width:100%"></div></div>
      </div>
      <div class="wave">Gelombang: <span id="wave">1</span></div>
    </div>

    <div class="controls" id="desktopControls">
      <small>Kontrol: ‚Üê ‚Üí / A D ‚Äî Lompat: ‚Üë / W ‚Äî Serang: Space (tahan)</small>
      <small style="margin-top:4px">Tekan ESC untuk pause</small>
      <div style="margin-top:8px">
        <button id="muteBtn" class="btn" style="padding:6px 10px;font-size:12px">üîä</button>
      </div>
    </div>

    <div id="overlayStart" class="centerOverlay">
      <h1 style="margin:0">ü¶Ü Bebek Manyun vs Zombi üßü</h1>
      <p style="margin:0">Tekan tombol <strong>Mulai Bermain</strong>. Gunakan Space (tahan) untuk menembak. Coba double-jump!</p>
      <button id="startBtn" class="btn">üéÆ Mulai Bermain</button>
      <small style="color:#94a3b8">Cocok untuk desktop dan mobile</small>
    </div>
  </div>

  <!-- Touch area under game (so it won't overlap canvas) -->
  <div id="touchArea" aria-hidden="false">
    <div class="touch-controls" id="touchControls" style="display:none">
      <div class="touch-button" id="leftBtn">‚óÄ</div>
      <div class="touch-button" id="jumpBtn">‚ñ≤</div>
      <div class="touch-button" id="rightBtn">‚ñ∂</div>
      <div class="touch-button" id="attackBtn">QUAK</div>
    </div>
  </div>

<script>
// ===== Bebek Manyun ‚Äî Audio + Touch layout fixes =====

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W = 900, H = 600;
let GROUND_Y = H - 80;

const overlay = document.getElementById('overlayStart');
const startBtn = document.getElementById('startBtn');
const scoreEl = document.getElementById('score');
const hpEl = document.getElementById('hp');
const hpBar = document.getElementById('hpBar');
const waveEl = document.getElementById('wave');
const touchControls = document.getElementById('touchControls');
const muteBtn = document.getElementById('muteBtn');
const attackBtn = document.getElementById('attackBtn');

let running = false;
let paused = false;
let score = 0;
let wave = 1;
let spawnTimer = 0;
let spawnInterval = 120;
let entities = [];
let particles = [];
let keys = {};
let keysPressed = {};
let highScore = parseInt(localStorage.getItem('bebekHighScore') || '0');

const MAX_PARTICLES = 450;

const player = {
  x: 120, y: 0, w: 60, h: 48,
  vx: 0, vy: 0, speed: 4.2,
  onGround: false,
  hp: 100, maxHp: 100,
  attackCooldown: 0,
  invulnerable: 0,
  facing: 1, canDoubleJump: true
};

const GRAV = 0.6, FRICTION = 0.88;

// ---------------- WebAudio (music + sfx) ----------------
let audioCtx = null;
let masterGain = null;
let muted = false;
let musicNode = null; // for background music interval
let zombieMoanBuffer = null;

function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;
  masterGain.connect(audioCtx.destination);
  loadZombieMoan(); // prepare moan sample (synth)
  startBackgroundMusic();
}

function playOsc({type='sine', freq=440, dur=0.12, vol=0.5, pan=0} = {}){
  if(!audioCtx || muted) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  const p = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;
  o.type = type; o.frequency.value = freq;
  g.gain.value = 0;
  o.connect(g);
  if(p){ g.connect(p); p.connect(masterGain); if(p.pan) p.pan.value = pan; }
  else g.connect(masterGain);
  const now = audioCtx.currentTime;
  g.gain.setValueAtTime(0, now);
  g.gain.linearRampToValueAtTime(vol, now + 0.01);
  g.gain.exponentialRampToValueAtTime(0.001, now + dur);
  o.start(now); o.stop(now + dur + 0.03);
}

function playNoise({dur=0.08, vol=0.6} = {}){
  if(!audioCtx || muted) return;
  const bufferSize = Math.floor(audioCtx.sampleRate * dur);
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * Math.exp(-i / (bufferSize*0.8));
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const g = audioCtx.createGain(); g.gain.value = vol;
  src.connect(g); g.connect(masterGain);
  src.start();
}

function playSound(name){
  if(!audioCtx || muted) return;
  switch(name){
    case 'quack':
      playOsc({type:'square', freq:600, dur:0.06, vol:0.12});
      playOsc({type:'sine', freq:900, dur:0.10, vol:0.06});
      break;
    case 'gun':
      playOsc({type:'square', freq:1200, dur:0.06, vol:0.28});
      playNoise({dur:0.06, vol:0.14});
      break;
    case 'hit':
      playOsc({type:'sine', freq:120, dur:0.16, vol:0.22});
      playNoise({dur:0.05, vol:0.06});
      break;
    case 'enemyDie':
      playOsc({type:'triangle', freq:200, dur:0.22, vol:0.18});
      playOsc({type:'sine', freq:380, dur:0.16, vol:0.10});
      break;
    case 'zombieMoan':
      // if we have a buffer, play it; otherwise fallback
      if(zombieMoanBuffer){
        const src = audioCtx.createBufferSource();
        src.buffer = zombieMoanBuffer;
        const g = audioCtx.createGain(); g.gain.value = 0.28;
        src.connect(g); g.connect(masterGain);
        src.start();
      } else {
        playOsc({type:'sine', freq:80, dur:0.6, vol:0.12});
        playNoise({dur:0.15, vol:0.08});
      }
      break;
    case 'gameOver':
      playOsc({type:'square', freq:90, dur:0.6, vol:0.22});
      break;
    default: break;
  }
}

// create a short zombie moan buffer (synth) to sound more natural
function loadZombieMoan(){
  if(!audioCtx) return;
  const dur = 0.8;
  const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * dur), audioCtx.sampleRate);
  const ch = buf.getChannelData(0);
  for(let i=0;i<ch.length;i++){
    const t = i / audioCtx.sampleRate;
    // low sine + noisy envelope to simulate moan
    ch[i] = (Math.sin(2*Math.PI*(60 + Math.sin(t*2)*6) * t) * 0.6 + (Math.random()*2-1)*0.18) * Math.exp(-t*0.8);
  }
  zombieMoanBuffer = buf;
}

// Simple background music loop (synthy melody)
let musicInterval = null;
function startBackgroundMusic(){
  if(!audioCtx || muted) return;
  if(musicInterval) return;
  // small sequence using oscillators scheduled repeatedly
  const notes = [440, 392, 349, 392, 440, 523, 440, 349]; // simple melody
  function scheduleMelody(){
    const now = audioCtx.currentTime;
    for(let i=0;i<notes.length;i++){
      const t = now + i * 0.32;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = notes[i] * (Math.random()*0.02 + 0.99);
      g.gain.value = 0;
      o.connect(g); g.connect(masterGain);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.08, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
      o.start(t); o.stop(t + 0.3);
    }
  }
  scheduleMelody();
  musicInterval = setInterval(scheduleMelody, notes.length * 320);
}

function stopBackgroundMusic(){
  if(musicInterval){ clearInterval(musicInterval); musicInterval = null; }
}

// ---------------- Helpers ----------------
function rand(min, max){ return Math.random()*(max-min)+min; }

// ---------------- Spawns ----------------
function spawnZombie(){
  const z = {
    type: 'zombie',
    x: W + 60,
    y: GROUND_Y - 48,
    w: 52, h: 64,
    vx: rand(-1.6, -1.0) - Math.min(0.8, score/400),
    hp: 20 + Math.floor(score/40) + wave * 5,
    maxHp: 20 + Math.floor(score/40) + wave * 5,
    attackTimer: 0,
    walkPhase: Math.random()*Math.PI*2
  };
  entities.push(z);
  // play a random low moan shortly after spawn
  setTimeout(()=>{ playSound('zombieMoan'); }, Math.random()*600);
  if(audioCtx && !musicInterval) startBackgroundMusic();
}

function spawnBat(){
  const b = {
    type: 'bat',
    x: W + 60,
    y: rand(120, GROUND_Y-200),
    w:40, h:30,
    vx: rand(-2.6, -1.6),
    hp: 10 + wave * 2,
    maxHp: 10 + wave * 2,
    wobble: Math.random()*10
  };
  entities.push(b);
}

// ---------------- Shooting ----------------
function shoot(){
  if(player.attackCooldown > 0) return;
  player.attackCooldown = 12;
  const p = {
    type: 'quack',
    x: player.x + (player.facing > 0 ? player.w : -22),
    y: player.y + 18,
    vx: 10 * player.facing,
    w: 20, h: 12,
    dmg: 18 + Math.floor(wave/2)
  };
  entities.push(p);
  createParticles(p.x, p.y, 4, '#8be0ff');
  playSound('gun');
}

// ---------------- Particles ----------------
function createParticles(x,y,count,color){
  for(let i=0;i<count;i++){
    particles.push({
      x: x,
      y: y,
      vx: rand(-3,3),
      vy: rand(-4,-1),
      life: 30,
      maxLife: 30,
      color: color || '#ffd54a',
      size: rand(3,8)
    });
  }
  if(particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
}

// ---------------- Update ----------------
function update(){
  if(!running || paused) return;

  if(keys['ArrowLeft'] || keys['a']){
    player.vx = Math.max(player.vx - 0.85, -player.speed);
    player.facing = -1;
  }
  if(keys['ArrowRight'] || keys['d']){
    player.vx = Math.min(player.vx + 0.85, player.speed);
    player.facing = 1;
  }
  if(!(keys['ArrowLeft']||keys['a']||keys['ArrowRight']||keys['d'])) player.vx *= FRICTION;

  if(keysPressed['up']){
    keysPressed['up'] = false;
    if(player.onGround){
      player.vy = -18; player.onGround = false; player.canDoubleJump = true;
      playSound('quack');
    } else if(player.canDoubleJump){
      player.vy = -15; player.canDoubleJump = false;
      createParticles(player.x + player.w/2, player.y + player.h/2, 8, '#8be0ff');
      playSound('quack');
    }
  }

  if(keys[' ']) shoot();

  player.vy += GRAV; player.x += player.vx; player.y += player.vy;

  if(player.y + player.h >= GROUND_Y){
    const wasAir = !player.onGround;
    player.y = GROUND_Y - player.h;
    player.vy = 0; player.onGround = true;
    if(wasAir) player.canDoubleJump = true;
  }
  if(player.x < 10) player.x = 10;
  if(player.x + player.w > W - 10) player.x = W - 10 - player.w;
  if(player.attackCooldown>0) player.attackCooldown--;
  if(player.invulnerable>0) player.invulnerable--;

  if(score > wave * 150 && entities.filter(e=>e.type==='zombie'||e.type==='bat').length === 0){
    wave++; waveEl.textContent = wave; spawnInterval = Math.max(28, 120 - wave * 8);
  }

  spawnTimer++;
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    const sc = Math.min(0.72, 0.25 + score/260);
    if(Math.random() < sc) spawnZombie();
    if(Math.random() < 0.15 + Math.min(0.45, score/520)) spawnBat();
  }

  for(let i=entities.length-1;i>=0;i--){
    const e = entities[i];
    if(e.type === 'zombie'){
      e.x += e.vx; e.walkPhase += 0.08 * Math.abs(e.vx) * 1.4; e.attackTimer++;
      if(e.x < player.x + player.w && e.x + e.w > player.x &&
         e.y + e.h > player.y + 10 && e.attackTimer > 30 && player.invulnerable <= 0){
        player.hp -= 6; player.invulnerable = 28; e.attackTimer = 0;
        createParticles(player.x + player.w/2, player.y + player.h/2, 6, '#ff4444'); playSound('hit');
      }
      if(e.x + e.w < -60) entities.splice(i,1);
    }
    if(e.type === 'bat'){
      e.x += e.vx; e.wobble += 0.18; e.y += Math.sin(e.wobble) * 1.6;
      if(e.x < player.x + player.w && e.x + e.w > player.x &&
         e.y < player.y + player.h && e.y + e.h > player.y && player.invulnerable <= 0){
        player.hp -= 3; player.invulnerable = 26; createParticles(player.x + player.w/2, player.y + player.h/2, 4, '#ff4444'); playSound('hit');
      }
      if(e.x + e.w < -60) entities.splice(i,1);
    }
    if(e.type === 'quack'){
      e.x += e.vx;
      for(let j=entities.length-1;j>=0;j--){
        const t = entities[j]; if(t===e) continue;
        if(t.type==='zombie' || t.type==='bat'){
          if(e.x < t.x + t.w && e.x + e.w > t.x &&
             e.y < t.y + t.h && e.y + e.h > t.y){
            t.hp -= e.dmg; t.x += 10 * Math.sign(e.vx);
            createParticles(t.x + t.w/2, t.y + t.h/2, 8, '#22c55e');
            const idx = entities.indexOf(e); if(idx>=0) entities.splice(idx,1); break;
          }
        }
      }
      if(e.x < -100 || e.x > W + 100){ const idx = entities.indexOf(e); if(idx>=0) entities.splice(idx,1); }
    }

    if((e.type==='zombie' || e.type==='bat') && e.hp <= 0){
      const pts = (e.type==='zombie')? 35 : 16; score += pts;
      createParticles(e.x + e.w/2, e.y + e.h/2, 14, '#ffd54a'); playSound('enemyDie'); entities.splice(i,1);
    }
  }

  if(!entities.some(x=>x.type==='zombie') && musicInterval) {
    // keep music but stop moan loop if none
  }

  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.28; p.life--; if(p.life <= 0) particles.splice(i,1);
  }

  if(player.hp <= 0){ playSound('gameOver'); endGame(); }

  scoreEl.textContent = Math.floor(score);
  hpEl.textContent = Math.max(0, Math.floor(player.hp));
  hpBar.style.width = Math.max(0, (player.hp / player.maxHp) * 100) + '%';
  if(player.hp > 60) hpBar.style.background = 'linear-gradient(90deg,#22c55e,#16a34a)';
  else if(player.hp > 30) hpBar.style.background = 'linear-gradient(90deg,#eab308,#ca8a04)';
  else hpBar.style.background = 'linear-gradient(90deg,#ef4444,#dc2626)';
}

// ---------------- Draw (same as before, adjusted weapon pos) ----------------
function draw(){
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#cfefff'); g.addColorStop(1,'#eaf9ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  const cloudOffset = (Date.now() % 60000) / 120;
  for(let i=0;i<5;i++){ ctx.globalAlpha = 0.22; ctx.beginPath(); ctx.ellipse(100 + i*200 + cloudOffset, 80 + Math.sin(i)*18, 92, 36, 0, 0, Math.PI*2); ctx.fillStyle='#ffffff'; ctx.fill(); ctx.globalAlpha = 1; }

  ctx.fillStyle = '#6b8f2f'; ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  ctx.fillStyle = '#5a7a28';
  for(let i=0;i<20;i++) ctx.fillRect(i*45 - (Date.now()/20)%45, GROUND_Y, 25, 4);

  for(const p of particles){ ctx.globalAlpha = p.life / p.maxLife; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }

  if(player.invulnerable <= 0 || Math.floor(Date.now()/100) % 2 === 0) drawDuck(player.x, player.y, player.w, player.h, player.facing);

  for(const e of entities){
    if(e.type === 'zombie') drawZombie(e.x, e.y, e.w, e.h, e.walkPhase);
    if(e.type === 'bat') drawBat(e.x, e.y, e.w, e.h);
    if(e.type === 'quack') drawQuack(e.x, e.y, e.w, e.h);

    if(e.type === 'zombie' || e.type === 'bat'){
      const hpPct = Math.max(0, e.hp / (e.maxHp || 1));
      ctx.fillStyle = '#334155'; ctx.fillRect(e.x, e.y - 8, e.w, 4);
      ctx.fillStyle = hpPct > 0.5 ? '#22c55e' : hpPct > 0.25 ? '#eab308' : '#ef4444';
      ctx.fillRect(e.x, e.y - 8, e.w * hpPct, 4);
    }
  }

  if(paused){ ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle = '#fff'; ctx.font = 'bold 48px Inter'; ctx.textAlign = 'center'; ctx.fillText('PAUSE', W/2, H/2); ctx.font='18px Inter'; ctx.fillText('Tekan ESC untuk melanjutkan', W/2, H/2 + 40); ctx.textAlign = 'left'; }
}

function drawDuck(x,y,w,h,facing){
  ctx.save(); ctx.translate(x + w/2, y + h/2); ctx.scale(facing,1); ctx.translate(-(x + w/2), -(y + h/2));
  const bodyX = x + w*0.45, bodyY = y + h*0.5;
  ctx.beginPath(); ctx.fillStyle = '#ffd754'; ctx.ellipse(bodyX, bodyY, w*0.45, h*0.55, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.ellipse(bodyX - 8, bodyY + 4, w*0.32, h*0.35, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ffcc33'; ctx.beginPath(); ctx.ellipse(x + w*0.25, y + h*0.5, w*0.18, h*0.28, -0.3, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ffd754'; ctx.beginPath(); ctx.arc(x + w*0.4, y + h*0.28, w*0.22, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x + w*0.33, y + h*0.25, 7,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#052022'; ctx.beginPath(); ctx.arc(x + w*0.33, y + h*0.25, 4,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#5b3a00'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x + w*0.28, y + h*0.35); ctx.quadraticCurveTo(x + w*0.33, y + h*0.40, x + w*0.40, y + h*0.35); ctx.stroke();
  ctx.fillStyle = '#ff8a00'; ctx.fillRect(x + w*0.28, y+h-6, 10, 4); ctx.fillRect(x + w*0.54, y+h-6, 10, 4);
  // weapon (adjusted)
  ctx.save();
  const gunX = x + w*0.5; const gunY = y + h*0.42;
  ctx.translate(gunX, gunY); ctx.rotate(-0.12);
  ctx.fillStyle = '#333'; ctx.fillRect(-8, -5, 60, 9);
  ctx.fillStyle = '#222'; ctx.beginPath(); ctx.moveTo(18, -5); ctx.lineTo(30, -5); ctx.lineTo(30, 7); ctx.lineTo(18, 7); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#111'; ctx.fillRect(48, -2, 22, 3); ctx.fillStyle = '#2b2b2b'; ctx.fillRect(4, 6, 8, 14);
  ctx.restore();
  ctx.restore();
}

function drawZombie(x,y,w,h,phase=0){
  ctx.save(); ctx.translate(x,y); ctx.fillStyle = '#6aa56a'; ctx.fillRect(8,20,w-16,h-20); ctx.fillRect(4,0,w-8,24);
  const swing = Math.sin(phase) * 6; ctx.fillStyle = '#5c9f5b'; ctx.fillRect(-2, 28 + swing*0.6, 8, 25); ctx.fillRect(w-6, 28 - swing*0.6, 8, 25);
  ctx.fillStyle = '#fff'; ctx.fillRect(12,6,10,10); ctx.fillRect(w-22,6,10,10); ctx.fillStyle = '#8b0000'; ctx.fillRect(15,9,4,4); ctx.fillRect(w-19,9,4,4);
  ctx.fillStyle = '#062b3a'; ctx.fillRect(w*0.3, 18, w*0.4, 3);
  const legShift = Math.sin(phase) * 4; ctx.fillRect(w*0.2, h-10 + legShift, 10, 12); ctx.fillRect(w*0.6, h-10 - legShift, 10, 12); ctx.restore();
}

function drawBat(x,y,w,h){
  ctx.save(); ctx.translate(x,y); ctx.fillStyle = '#2d2d2d'; ctx.beginPath(); ctx.ellipse(w*0.5, h*0.5, w*0.3, h*0.4, 0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#3b3b3b'; ctx.beginPath(); ctx.ellipse(w*0.15, h*0.5, w*0.35, h*0.3, -0.5,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(w*0.85, h*0.5, w*0.35, h*0.3, 0.5,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(w*0.4, h*0.4, 3,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(w*0.6, h*0.4, 3,0,Math.PI*2); ctx.fill(); ctx.restore();
}

function drawQuack(x,y,w,h){ ctx.fillStyle = '#8be0ff'; ctx.beginPath(); ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#062b3a'; ctx.font='bold 10px Inter'; ctx.fillText('Q', x+5, y+9); }

// ---------------- Loop control ----------------
function loop(){ update(); draw(); if(running) requestAnimationFrame(loop); }

function startGame(){
  initAudio();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  running = true; paused = false;
  score = 0; wave = 1; entities = []; particles = [];
  player.hp = 100; player.x = 120; player.y = GROUND_Y - player.h; player.vx=0; player.vy=0;
  player.invulnerable = 0; player.facing = 1; player.canDoubleJump = true;
  spawnTimer = 0; spawnInterval = 120;
  overlay.style.display = 'none';
  // show touch controls if mobile
  touchControls.style.display = /Mobi|Android/i.test(navigator.userAgent) ? 'flex' : 'none';
  requestAnimationFrame(loop);
}

function endGame(){
  running = false;
  if(score > highScore){ highScore = score; localStorage.setItem('bebekHighScore', highScore); }
  overlay.style.display = 'flex';
  overlay.querySelector('h1').textContent = '‚ò†Ô∏è Game Over!';
  overlay.querySelector('p').innerHTML = `<strong>Skor Akhir: ${Math.floor(score)}</strong><br>Gelombang: ${wave}<br>High Score: ${highScore}<br><br>Tekan tombol untuk bermain lagi!`;
}

// ---------------- Input ----------------
window.addEventListener('keydown', e=>{
  if(e.code === 'Space'){ e.preventDefault(); keys[' '] = true; }
  if(e.key === 'ArrowUp' || e.key === 'w'){ keysPressed['up'] = true; }
  keys[e.key] = true;
  if(e.key === 'Escape') togglePause();
});
window.addEventListener('keyup', e=>{
  if(e.code === 'Space'){ keys[' '] = false; }
  keys[e.key] = false;
});

// Attack hold functions
function startFiring(){ keys[' '] = true; }
function stopFiring(){ keys[' '] = false; }

attackBtn && attackBtn.addEventListener('touchstart', e=>{ e.preventDefault(); startFiring(); });
attackBtn && attackBtn.addEventListener('touchend', e=>{ e.preventDefault(); stopFiring(); });
attackBtn && attackBtn.addEventListener('touchcancel', e=>{ e.preventDefault(); stopFiring(); });
attackBtn && attackBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); startFiring(); });
window.addEventListener('pointerup', e=>{ stopFiring(); });

function addTouch(btn, key, isOneShot=false){
  if(!btn) return;
  btn.addEventListener('touchstart', e=>{ e.preventDefault(); if(isOneShot) keysPressed[key]=true; else keys[key]=true; });
  btn.addEventListener('touchend', e=>{ e.preventDefault(); if(!isOneShot) keys[key]=false; });
  btn.addEventListener('touchcancel', e=>{ e.preventDefault(); if(!isOneShot) keys[key]=false; });
}
addTouch(document.getElementById('leftBtn'), 'ArrowLeft');
addTouch(document.getElementById('rightBtn'), 'ArrowRight');
addTouch(document.getElementById('jumpBtn'), 'up', true);

muteBtn.addEventListener('click', ()=>{
  muted = !muted;
  muteBtn.textContent = muted ? 'üîá' : 'üîä';
  if(masterGain) masterGain.gain.value = muted ? 0 : 0.9;
  if(muted) stopBackgroundMusic(); else startBackgroundMusic();
});

// ---------------- Responsive sizing (fit Galaxy A23 & others) ----------------
function resizeCanvas(){
  const wrap = document.getElementById('gameWrap');
  const rect = wrap.getBoundingClientRect();
  // target width is wrapper width; use logical canvas 900x600 scaled to CSS size
  const desiredWidth = Math.min(rect.width, 900);
  const desiredHeight = Math.round(desiredWidth * (600 / 900));
  canvas.style.width = desiredWidth + 'px';
  canvas.style.height = desiredHeight + 'px';
  // logical coords remain 900x600
  W = 900; H = 600; GROUND_Y = H - 80;
  if(player.x + player.w > W) player.x = W - player.w - 10;
  if(player.y + player.h > GROUND_Y) player.y = GROUND_Y - player.h;
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', ()=> setTimeout(resizeCanvas, 200));
resizeCanvas();

// prevent context menu
document.querySelectorAll('.touch-button').forEach(btn => btn.addEventListener('contextmenu', e=>e.preventDefault()));

// demo start screen
let demoTimer = 0;
function demoAnimation(){
  if(!running){
    demoTimer++;
    if(demoTimer > 90 && Math.random() < 0.12){
      if(Math.random() < 0.5) spawnZombie(); else spawnBat();
      demoTimer = 0;
    }
    for(let i=entities.length-1;i>=0;i--){
      const e = entities[i]; e.x += e.vx; if(e.wobble !== undefined){ e.wobble += 0.15; e.y += Math.sin(e.wobble)*1.5; } if(e.x < -120) entities.splice(i,1);
    }
    draw(); requestAnimationFrame(demoAnimation);
  }
}
demoAnimation();
startBtn.addEventListener('click', ()=>{ startGame(); });

// pause
function togglePause(){ if(!running) return; paused = !paused; if(!paused) requestAnimationFrame(loop); }

console.log('Fix terbaru siap ‚Äî tekan Mulai Bermain lalu coba di HP (Galaxy A23).');
</script>
</body>
</html>
